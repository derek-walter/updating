# Updating Chart

Using asyncio and ipywidgets to generate an updating/stale chart object. 

Workarounds:
1. Resource control
- The IPython kernel is typically preoccupied with any looping that occurs in scripting. By using the asyncio package, we can free the kernel within a loop to reobserve state changes in the widgets. Widgets are eventful objects, and upon initialization, the widgets become a coroutine. As such, when the kernel is freed using async/await syntax, it can resume the sync between the widget instance and the displayed widget instance. This allows a widget to be monitored within a  loop. Two tasks should be running at any given time: The base widget task that begins upon initialization of a widget object, and an asyncio Task (future). The syntax for this is asyncio.Task(awaitable_routine). A call using the above will deploy a task to the scheduler. There are other ways to call tasks/futures, but syntax changes frequently. One could replace asyncio.Task(awaitable_routine) with asyncio.ensure_future(awaitable_routine) with no change to functionality. It's important to note that no loop call is required in IPython environment. Either call above actually initializes the tasks. As such, it is common to put those tasks in respective functions and use another function, say async def main() which employs some type of `gather` of the tasks. asyncio.gather({set of tasks}) within async def main() would then initiate each subtask. 
2. IPython display
- When syntax is used such as `out = widgets.Output(), with out: render things` any available output that appears in (I believe the entire notebook) will be cast to the `out` object. As such, one can display() the widgets to the IPython display (Shown by any basic call to display without an enclosing display object) repeatedly and cause no re-rendering. Though, within the `with out:` we clear the out object (not the IPython display) and re-render the chart. This allows the two to be paired and displayed where only the chart is updated. One should note that displaying a widget does not reinitialize it, it only reaffirms the jslink or kernel link to the front end. Since widgets are stateful, the same widget in the background is reproduced in a display sense. 
